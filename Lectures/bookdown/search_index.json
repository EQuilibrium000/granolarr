[
["index.html", "Geographic data science reproducible teaching resource in RLecture materials Preface 0.1 Session info", " Geographic data science reproducible teaching resource in RLecture materials Stefano De Sabbata 2019-11-19 Preface Stefano De Sabbata This work is licensed under the GNU General Public License v3.0. Contains public sector information licensed under the Open Government Licence v3.0. This book contains the lectures component of granolarr, a repository of reproducible materials to teach geographic information and data science in R. Part of the materials are derived from the lectures for the module GY7702 Practical Programming in R of the MSc in Geographic Information Science at the School of Geography, Geology, and the Environment of the University of Leicester, by Dr Stefano De Sabbata. This book was created using R, RStudio, RMarkdown, Bookdown, and GitHub. 0.1 Session info sessionInfo() ## R version 3.6.1 (2019-07-05) ## Platform: x86_64-apple-darwin15.6.0 (64-bit) ## Running under: macOS Mojave 10.14.6 ## ## Matrix products: default ## BLAS: /Library/Frameworks/R.framework/Versions/3.6/Resources/lib/libRblas.0.dylib ## LAPACK: /Library/Frameworks/R.framework/Versions/3.6/Resources/lib/libRlapack.dylib ## ## locale: ## [1] en_GB.UTF-8/en_GB.UTF-8/en_GB.UTF-8/C/en_GB.UTF-8/en_GB.UTF-8 ## ## attached base packages: ## [1] stats graphics grDevices utils datasets methods base ## ## loaded via a namespace (and not attached): ## [1] compiler_3.6.1 magrittr_1.5 bookdown_0.14 tools_3.6.1 ## [5] htmltools_0.4.0 yaml_2.2.0 Rcpp_1.0.2 stringi_1.4.3 ## [9] rmarkdown_1.16 knitr_1.25 stringr_1.4.0 xfun_0.10 ## [13] digest_0.6.21 rlang_0.4.0 evaluate_0.14 "],
["about-this-module.html", "1 About this module 1.1 About this module 1.2 R programming language 1.3 Schedule 1.4 Reference book", " 1 About this module 1.1 About this module This module will provide you with the fundamental skills in basic programming in R reproducibility data wrangling data analysis basis for Geospatial Data Analysis Geospatial Databases and Information Retrieval as well as Geographical Visualisation 1.2 R programming language One of the most widely used programming languages and an effective tool for (geospatial) data science data wrangling statistical analysis machine learning data visualisation and maps processing spatial data geographic information analysis 1.3 Schedule Lectures: Wednesdays, 09:00 - 10:00, Attenborough 205 Practicals: Thursdays, 15:00 - 17:00, David Wilson Library IT R1 1.3.1 Topics GIScience, Programming and Reproducibility Data types Data wrangling Control structures and functions Reproducibility Exploratory data analysis Univariate analysis Multivariate analysis Unsupervised machine learning Supervised machine learning 1.4 Reference book Programming Skills for Data Science: Start Writing Code to Wrangle, Analyze, and Visualize Data with R Michael Freeman and Joel Ross Addison-Wesley, 2019 See book webpage See book repository "],
["r.html", "2 R 2.1 R 2.2 Interpreting values 2.3 Basic types 2.4 Numeric operators 2.5 Logical operators 2.6 Variables 2.7 Algorithms and functions 2.8 Functions 2.9 Functions and variables 2.10 Naming 2.11 Coding style 2.12 R libraries 2.13 stringr 2.14 The pipe operator 2.15 Pipe example 2.16 Pipe example", " 2 R 2.1 R Created in 1992 by Ross Ihaka and Robert Gentleman at the University of Auckland, New Zealand Free, open-source implementation of S statistical programming language Bell Labs Functional programming language Supports (and commonly used as) procedural (i.e., imperative) programming Object-oriented Interpreted (not compiled) 2.2 Interpreting values When values and operations are inputted in the Console, the interpreter returns the results of its interpretation of the expression 2 ## [1] 2 &quot;String value&quot; ## [1] &quot;String value&quot; # comments are ignored 2.3 Basic types R provides three core data types numeric both integer and real numbers character i.e., text, also called strings logical TRUE or FALSE 2.4 Numeric operators R provides a series of basic numeric operators Operator Meaning Example Output + Plus 5 + 2 7 - Minus 5 - 2 3 * Product 5 * 2 10 / Division 5 / 2 2.5 %/% Integer division 5 %/% 2 2 %% Module 5 %% 2 1 ^ Power 5^2 25 5 + 2 ## [1] 7 2.5 Logical operators R provides a series of basic logical operators to test Operator Meaning Example Output == Equal 5 == 2 FALSE != Not equal 5 != 2 TRUE &gt; (&gt;=) Greater (or equal) 5 &gt; 2 TRUE &lt; (&lt;=) Less (or equal) 5 &lt;= 2 FALSE ! Not !TRUE FALSE &amp; And TRUE &amp; FALSE FALSE | Or TRUE | FALSE TRUE 5 &gt;= 2 ## [1] TRUE 2.6 Variables Variables store data and can be defined using an identifier (e.g., a_variable) on the left of an assignment operator &lt;- followed by the object to be linked to the identifier such as a value (e.g., 1) a_variable &lt;- 1 The value of the variable can be invoked by simply specifying the identifier. a_variable ## [1] 1 2.7 Algorithms and functions An algorithm or effective procedure is a mechanical rule, or automatic method, or programme for performing some mathematical operation (Cutland, 1980). A program is a specific set of instructions that implement an abstract algorithm. The definition of an algorithm (and thus a program) can consist of one or more functions set of instructions that preform a task possibly using an input, possibly returning an output value Programming languages usually provide pre-defined functions that implement common algorithms (e.g., to find the square root of a number or to calculate a linear regression) 2.8 Functions Functions execute complex operations and can be invoked specifying the function name the arguments (input values) between simple brackets each argument corresponds to a parameter sometimes the parameter name must be specified sqrt(2) ## [1] 1.414214 round(1.414214, digits = 2) ## [1] 1.41 2.9 Functions and variables functions can be used on the right side of &lt;- variables and functions can be used as arguments sqrt_of_two &lt;- sqrt(2) sqrt_of_two ## [1] 1.414214 round(sqrt_of_two, digits = 2) ## [1] 1.41 round(sqrt(2), digits = 2) ## [1] 1.41 2.10 Naming When creating an identifier for a variable or function R is a case sensitive language UPPER and lower case are not the same a_variable is different from a_VARIABLE names can include alphanumeric symbols . and _ names must start with a letter 2.11 Coding style A coding style is a way of writing the code, including how variable and functions are named lower case and _ how spaces are used in the code which libraries are used # Bad X&lt;-round(sqrt(2),2) #Good sqrt_of_two &lt;- sqrt(2) %&gt;% round(digits = 2) Study the Tidyverse Style Guid and use it consistently! 2.12 R libraries Libraries are collections of functions and/or datasets. installed in R using the function install.packages loaded using the function library every script needs to load all the library that it uses install.packages(&quot;tidyverse&quot;) library(tidyverse) The meta-library Tidyverse contains many libraries, including stringr. 2.13 stringr R provides some basic functions to manipulate strings, but the stringr library provides a more consistent and well-defined set str_length(&quot;Leicester&quot;) ## [1] 9 str_detect(&quot;Leicester&quot;, &quot;e&quot;) ## [1] TRUE str_replace_all(&quot;Leicester&quot;, &quot;e&quot;, &quot;x&quot;) ## [1] &quot;Lxicxstxr&quot; 2.14 The pipe operator The Tidyverse also provide a clean and effective way of combining multiple manipulation steps The pipe operator %&gt;% takes the result from one function and passes it to the next function as the first argument that doesn’t need to be included in the code anymore 2.15 Pipe example 2.16 Pipe example The two codes below are equivalent the first simply invokes the functions the second uses the pipe operator %&gt;% round(sqrt(2), digits = 2) ## [1] 1.41 sqrt(2) %&gt;% round(digits = 2) ## [1] 1.41 "],
["summary.html", "3 Summary 3.1 Summary 3.2 Practical session 3.3 Next week", " 3 Summary 3.1 Summary An introduction to R Basic types Basic operators variables Libraries The pipe operator Coding style 3.2 Practical session In the practical session, we will see The R programming language Interpreting values Variables Basic types Tidyverse Coding style 3.3 Next week More complex data types Vectors Factors Matrices Arrays Lists Data Frames "],
["recap-102.html", "4 Recap @ 102 4.1 Previous lecture 4.2 Today", " 4 Recap @ 102 4.1 Previous lecture An introduction to R Basic types Basic operators Variables Libraries The pipe operator Coding style 4.2 Today More complex data types Vectors Factors Matrices Arrays Lists Data Frames "],
["vectors.html", "5 Vectors 5.1 Vectors 5.2 Defining vectors 5.3 Creating vectors 5.4 Selection 5.5 Functions on vectors 5.6 Any and all", " 5 Vectors 5.1 Vectors Vectors are ordered list of values. Vectors can be of any data type numeric character logic All items in a vector have to be of the same type Vectors can be of any length 5.2 Defining vectors A vector variable can be defined using an identifier (e.g., a_vector) on the left of an assignment operator &lt;- followed by the object to be linked to the identifier in this case, the result returned by the function c which creates a vector containing the element provided as input a_vector &lt;- c(&quot;Birmingham&quot;, &quot;Derby&quot;, &quot;Leicester&quot;, &quot;Lincoln&quot;, &quot;Nottingham&quot;, &quot;Wolverhampton&quot;) a_vector ## [1] &quot;Birmingham&quot; &quot;Derby&quot; &quot;Leicester&quot; &quot;Lincoln&quot; ## [5] &quot;Nottingham&quot; &quot;Wolverhampton&quot; 5.3 Creating vectors the operator : the function seq the function rep 4:7 ## [1] 4 5 6 7 seq(1, 7, by = 0.5) ## [1] 1.0 1.5 2.0 2.5 3.0 3.5 4.0 4.5 5.0 5.5 6.0 6.5 7.0 seq(1, 10, length.out = 7) ## [1] 1.0 2.5 4.0 5.5 7.0 8.5 10.0 rep(&quot;Ciao&quot;, 4) ## [1] &quot;Ciao&quot; &quot;Ciao&quot; &quot;Ciao&quot; &quot;Ciao&quot; 5.4 Selection Each element of a vector can be retrieved specifying the related index between square brackets, after the identifier of the vector. The first element of the vector has index 1. a_vector[3] ## [1] &quot;Leicester&quot; A vector of indexes can be used to retrieve more than one element. a_vector[c(5, 3)] ## [1] &quot;Nottingham&quot; &quot;Leicester&quot; 5.5 Functions on vectors Functions can be used on a vector variable directly a_numeric_vector &lt;- 1:5 a_numeric_vector + 10 ## [1] 11 12 13 14 15 sqrt(a_numeric_vector) ## [1] 1.000000 1.414214 1.732051 2.000000 2.236068 a_numeric_vector &gt;= 3 ## [1] FALSE FALSE TRUE TRUE TRUE 5.6 Any and all Overall expressions can be tested using the functions: any, TRUE if any of the elements satisfies the condition all, TRUE if all of the elements satisfy the condition any(a_numeric_vector &gt;= 3) ## [1] TRUE all(a_numeric_vector &gt;= 3) ## [1] FALSE "],
["factors.html", "6 Factors 6.1 Factors 6.2 table 6.3 Specified levels 6.4 (Unordered) Factors 6.5 Ordered Factors", " 6 Factors 6.1 Factors A factor is a data type similar to a vector. However, the values contained in a factor can only be selected from a set of levels. houses_vector &lt;- c(&quot;Bungalow&quot;, &quot;Flat&quot;, &quot;Flat&quot;, &quot;Detached&quot;, &quot;Flat&quot;, &quot;Terrace&quot;, &quot;Terrace&quot;) houses_vector ## [1] &quot;Bungalow&quot; &quot;Flat&quot; &quot;Flat&quot; &quot;Detached&quot; &quot;Flat&quot; &quot;Terrace&quot; ## [7] &quot;Terrace&quot; houses_factor &lt;- factor(c(&quot;Bungalow&quot;, &quot;Flat&quot;, &quot;Flat&quot;, &quot;Detached&quot;, &quot;Flat&quot;, &quot;Terrace&quot;, &quot;Terrace&quot;)) houses_factor ## [1] Bungalow Flat Flat Detached Flat Terrace Terrace ## Levels: Bungalow Detached Flat Terrace 6.2 table The function table can be used to obtain a tabulated count for each level. houses_factor &lt;- factor(c(&quot;Bungalow&quot;, &quot;Flat&quot;, &quot;Flat&quot;, &quot;Detached&quot;, &quot;Flat&quot;, &quot;Terrace&quot;, &quot;Terrace&quot;)) houses_factor ## [1] Bungalow Flat Flat Detached Flat Terrace Terrace ## Levels: Bungalow Detached Flat Terrace table(houses_factor) ## houses_factor ## Bungalow Detached Flat Terrace ## 1 1 3 2 6.3 Specified levels A specific set of levels can be specified when creating a factor by providing a levels argument. houses_factor_spec &lt;- factor( c(&quot;People Carrier&quot;, &quot;Flat&quot;, &quot;Flat&quot;, &quot;Hatchback&quot;, &quot;Flat&quot;, &quot;Terrace&quot;, &quot;Terrace&quot;), levels = c(&quot;Bungalow&quot;, &quot;Flat&quot;, &quot;Detached&quot;, &quot;Semi&quot;, &quot;Terrace&quot;)) table(houses_factor_spec) ## houses_factor_spec ## Bungalow Flat Detached Semi Terrace ## 0 3 0 0 2 6.4 (Unordered) Factors In statistics terminology, (unordered) factors are categorical (i.e., binary or nominal) variables. Levels are not ordered. income_nominal &lt;- factor( c(&quot;High&quot;, &quot;High&quot;, &quot;Low&quot;, &quot;Low&quot;, &quot;Low&quot;, &quot;Medium&quot;, &quot;Low&quot;, &quot;Medium&quot;), levels = c(&quot;Low&quot;, &quot;Medium&quot;, &quot;High&quot;)) income_nominal &gt; &quot;Low&quot; ## Warning in Ops.factor(income_nominal, &quot;Low&quot;): &#39;&gt;&#39; not meaningful for ## factors ## [1] NA NA NA NA NA NA NA NA 6.5 Ordered Factors In statistics terminology, ordered factors are ordinal variables. Levels are ordered. income_ordered &lt;- ordered( c(&quot;High&quot;, &quot;High&quot;, &quot;Low&quot;, &quot;Low&quot;, &quot;Low&quot;, &quot;Medium&quot;, &quot;Low&quot;, &quot;Medium&quot;), levels = c(&quot;Low&quot;, &quot;Medium&quot;, &quot;High&quot;)) income_ordered &gt; &quot;Low&quot; ## [1] TRUE TRUE FALSE FALSE FALSE TRUE FALSE TRUE sort(income_ordered) ## [1] Low Low Low Low Medium Medium High High ## Levels: Low &lt; Medium &lt; High "],
["matrices-and-arrays.html", "7 Matrices and arrays 7.1 Matrices 7.2 Arrays 7.3 Arrays 7.4 Selection 7.5 apply", " 7 Matrices and arrays 7.1 Matrices Matrices are collections of numerics arranged in a two-dimensional rectangular layout the first argument is a vector of values the second specifies number of rows and columns R offers operators and functions for matrix algebra a_matrix &lt;- matrix(c(3, 5, 7, 4, 3, 1), c(3, 2)) a_matrix ## [,1] [,2] ## [1,] 3 4 ## [2,] 5 3 ## [3,] 7 1 7.2 Arrays Variables of the type array are higher-dimensional matrices. the first argument is a vector containing the values the second argument is a vector specifying the depth of each dimension a3dim_array &lt;- array(1:24, dim=c(4, 3, 2)) 7.3 Arrays a3dim_array ## , , 1 ## ## [,1] [,2] [,3] ## [1,] 1 5 9 ## [2,] 2 6 10 ## [3,] 3 7 11 ## [4,] 4 8 12 ## ## , , 2 ## ## [,1] [,2] [,3] ## [1,] 13 17 21 ## [2,] 14 18 22 ## [3,] 15 19 23 ## [4,] 16 20 24 7.4 Selection Subsets of matrices (and arrays) can be selected as seen for vectors. a_matrix[2, c(1, 2)] ## [1] 5 3 a3dim_array[c(1, 2), 2, 2] ## [1] 17 18 7.5 apply apply applies another function to each level of a set dimension of an array apply(a3dim_array, 3, min) # apply on third dimension ## [1] 1 13 apply(a3dim_array, 1, min) # apply on first dimension ## [1] 1 2 3 4 apply(a3dim_array, 2, min) # apply on second dimension ## [1] 1 5 9 "],
["lists.html", "8 Lists 8.1 Lists 8.2 Named Lists 8.3 lapply", " 8 Lists 8.1 Lists Variables of the type list can contain elements of different types (including vectors and matrices), whereas elements of vectors are all of the same type. employee &lt;- list(&quot;Stefano&quot;, 2015) employee ## [[1]] ## [1] &quot;Stefano&quot; ## ## [[2]] ## [1] 2015 employee[[1]] # Note the double square brackets for selection ## [1] &quot;Stefano&quot; 8.2 Named Lists In named lists each element has a name, and elements can be selected to using their name after the symbol $. employee &lt;- list(name = &quot;Stefano&quot;, start_year = 2015) employee ## $name ## [1] &quot;Stefano&quot; ## ## $start_year ## [1] 2015 employee$name ## [1] &quot;Stefano&quot; 8.3 lapply With lapply take care that the function makes sense for any element in the list various &lt;- list( &quot;Some text&quot;, matrix(c(6, 3, 1, 2), c(2, 2)) ) lapply(various, is.numeric) ## [[1]] ## [1] FALSE ## ## [[2]] ## [1] TRUE "],
["data-frames.html", "9 Data frames 9.1 Data Frames 9.2 Selection 9.3 Selection 9.4 Value assignment 9.5 Column processing 9.6 tibble", " 9 Data frames 9.1 Data Frames A data frame is equivalent to a named list where all elements are vectors of the same length. employees &lt;- data.frame( Name = c(&quot;Maria&quot;, &quot;Pete&quot;, &quot;Sarah&quot;), Age = c(47, 34, 32), Role = c(&quot;Professor&quot;, &quot;Researcher&quot;, &quot;Researcher&quot;)) employees ## Name Age Role ## 1 Maria 47 Professor ## 2 Pete 34 Researcher ## 3 Sarah 32 Researcher Data frames are the most common way to represent tabular data in R. Matrices and lists can be converted to data frames. 9.2 Selection Selection is similar to vectors and lists. employees[1, ] # row selection ## Name Age Role ## 1 Maria 47 Professor employees[, 1] # column selection, as for matrices ## [1] Maria Pete Sarah ## Levels: Maria Pete Sarah 9.3 Selection Selection is similar to vectors and lists. employees$Name # column selection, as for named lists ## [1] Maria Pete Sarah ## Levels: Maria Pete Sarah employees$Name[1] ## [1] Maria ## Levels: Maria Pete Sarah 9.4 Value assignment Values can be assigned to cells through filtering and &lt;- employees$Age[3] &lt;- 33 employees ## Name Age Role ## 1 Maria 47 Professor ## 2 Pete 34 Researcher ## 3 Sarah 33 Researcher 9.5 Column processing Operations can be performed on columns, and new columns created. current_year &lt;- as.integer(format(Sys.Date(), &quot;%Y&quot;)) employees$Year_of_birth &lt;- current_year - employees$Age employees ## Name Age Role Year_of_birth ## 1 Maria 47 Professor 1972 ## 2 Pete 34 Researcher 1985 ## 3 Sarah 33 Researcher 1986 9.6 tibble A tibble is a modern reimagining of the data.frame within tidyverse they do less don’t change variable names or types don’t do partial matching complain more e.g. when a variable does not exist This forces you to confront problems earlier, typically leading to cleaner, more expressive code. "],
["summary-2.html", "10 Summary 10.1 Summary 10.2 Practical session 10.3 Next week", " 10 Summary 10.1 Summary More complex data types Vectors Factors Matrices Arrays Lists Data Frames 10.2 Practical session In the practical session, we will see (surprise, surprise) Vectors Factors Matrices Arrays Lists Data Frames 10.3 Next week Moving on towards data science Data selection Data filtering Data manipulation Join operations Table re-shaping "],
["recap-111.html", "11 Recap @ 111 11.1 Previous lectures 11.2 Today", " 11 Recap @ 111 11.1 Previous lectures Moving from programming to data science Basic types and variables The pipe operator Coding style Complex data types Vectors Data Frames Data selection and filtering Join operations Table re-shaping 11.2 Today How to control the data processing flow Conditional statements Loops While For Functions Scope of a variable "],
["conditional-statements.html", "12 Conditional statements 12.1 If 12.2 Else 12.3 Code blocks", " 12 Conditional statements 12.1 If Format: if (condition) statement condition: expression returning a logic value (TRUE or FALSE) statement: any valid R statement statement only executed if condition is TRUE a_value &lt;- -7 if (a_value &lt; 0) cat(&quot;Negative&quot;) ## Negative a_value &lt;- 8 if (a_value &lt; 0) cat(&quot;Negative&quot;) 12.2 Else Format: if (condition) statement1 else statement2 condition: expression returning a logic value (TRUE or FALSE) statement1 and statement2: any valid R statements statement1 executed if condition is TRUE statement2 executed if condition is FALSE a_value &lt;- -7 if (a_value &lt; 0) cat(&quot;Negative&quot;) else cat(&quot;Positive&quot;) ## Negative a_value &lt;- 8 if (a_value &lt; 0) cat(&quot;Negative&quot;) else cat(&quot;Positive&quot;) ## Positive 12.3 Code blocks Suppose you want to execute several statements within a function, or if a condition is true Such a group of statements are called code blocks { and } contain code blocks first_value &lt;- 8 second_value &lt;- 5 if (first_value &gt; second_value) { cat(&quot;First is greater than second\\n&quot;) difference &lt;- first_value - second_value cat(&quot;Their difference is &quot;, difference) } ## First is greater than second ## Their difference is 3 "],
["loops.html", "13 Loops 13.1 Loops 13.2 While 13.3 For 13.4 For 13.5 Loops with conditional statements", " 13 Loops 13.1 Loops Loops are a fundamental component of (procedural) programming. There are two main types of loops: conditional loops are executed as long as a defined condition holds true construct while construct repeat deterministic loops are executed a pre-determined number of times construct for 13.2 While The while construct can be defined using the while reserved word, followed by the conditional statement between simple brackets, and a code block. The instructions in the code block are re-executed as long as the result of the evaluation of the conditional statement is TRUE. current_value &lt;- 0 while (current_value &lt; 3) { cat(&quot;Current value is&quot;, current_value, &quot;\\n&quot;) current_value &lt;- current_value + 1 } ## Current value is 0 ## Current value is 1 ## Current value is 2 13.3 For The for construct can be defined using the for reserved word, followed by the definition of an iterator. The iterator is a variable which is temporarily assigned with the current element of a vector, as the construct iterates through all elements of the list. This definition is followed by a code block, whose instructions are re-executed once for each element of the vector. cities &lt;- c(&quot;Derby&quot;, &quot;Leicester&quot;, &quot;Lincoln&quot;, &quot;Nottingham&quot;) for (city in cities) { cat(&quot;Do you live in&quot;, city, &quot;?\\n&quot;) } ## Do you live in Derby ? ## Do you live in Leicester ? ## Do you live in Lincoln ? ## Do you live in Nottingham ? 13.4 For It is common practice to create a vector of integers on the spot in order to execute a certain sequence of steps a pre-defined number of times. for (i in 1:3) { cat(&quot;This is exectuion number&quot;, i, &quot;:\\n&quot;) cat(&quot; See you later!\\n&quot;) } ## This is exectuion number 1 : ## See you later! ## This is exectuion number 2 : ## See you later! ## This is exectuion number 3 : ## See you later! 13.5 Loops with conditional statements 3:0 ## [1] 3 2 1 0 #Example: countdown! for (i in 3:0) { if (i == 0) { cat(&quot;Go!\\n&quot;) } else { cat(i, &quot;\\n&quot;) } } ## 3 ## 2 ## 1 ## Go! "],
["functions-1.html", "14 Functions 14.1 Defining functions 14.2 Defining functions 14.3 Defining functions 14.4 More parameters 14.5 Functions and control structures 14.6 Scope 14.7 Example", " 14 Functions 14.1 Defining functions A function can be defined using an identifier (e.g., add_one) on the left of an assignment operator &lt;- followed by the corpus of the function add_one &lt;- function (input_value) { output_value &lt;- input_value + 1 output_value } 14.2 Defining functions The corpus starts with the reserved word function followed by the parameter(s) (e.g., input_value) between simple brackets and the instruction(s) to be executed in a code block the value of the last statement is returned as output add_one &lt;- function (input_value) { output_value &lt;- input_value + 1 output_value } 14.3 Defining functions After being defined, a function can be invoked by specifying the identifier add_one (3) ## [1] 4 14.4 More parameters a function can be defined as having two or more parameters by specifying more than one parameter name (separated by commas) in the function definition a function always take as input as many values as the number of parameters specified in the definition otherwise an error is generated area_rectangle &lt;- function (hight, width) { area &lt;- hight * width area } area_rectangle(3, 2) ## [1] 6 14.5 Functions and control structures Functions can contain both loops and conditional statements in their corpus factorial &lt;- function (input_value) { result &lt;- 1 for (i in 1:input_value) { cat(&quot;current:&quot;, result, &quot; | i:&quot;, i, &quot;\\n&quot;) result &lt;- result * i } result } factorial(3) ## current: 1 | i: 1 ## current: 1 | i: 2 ## current: 2 | i: 3 ## [1] 6 14.6 Scope The scope of a variable is the part of code in which the variable is ``visible’’ In R, variables have a hierarchical scope: a variable defined in a script can be used referred to from within a definition of a function in the same scrip a variable defined within a definition of a function will not be referable from outside the definition scope does not apply to if or loop constructs 14.7 Example In the case below x_value is global to the function times_x new_value and input_value are local to the function times_x referring to new_value or input_value from outside the definition of times_x would result in an error x_value &lt;- 10 times_x &lt;- function (input_value) { new_value &lt;- input_value * x_value new_value } times_x(2) ## [1] 20 "],
["summary-4.html", "15 Summary 15.1 Summary 15.2 Practical session 15.3 Next week", " 15 Summary 15.1 Summary How to control the data processing flow Conditional statements Loops While For Functions Scope of a variable Debugging 15.2 Practical session In the practical session, we will see Conditional statements Loops While For Functions Loading functions from scripts Debugging 15.3 Next week Data visualisation histograms boxplots scatterplots Descriptive statistics Exploring assumptions Shapiro–Wilk test skewness and kurtosis Levene’s test "],
["recap-201.html", "16 Recap @ 201 16.1 Previous lectures 16.2 Today", " 16 Recap @ 201 16.1 Previous lectures Basis of R programming Basic types Variables The pipe operator Coding style Vectors Data Frames 16.2 Today Moving on towards data science Data selection Data filtering Data manipulation "],
["selection-and-filtering.html", "17 Selection and filtering 17.1 dplyr 17.2 Example dataset 17.3 dplyr::select 17.4 dplyr::select 17.5 Logical filtering 17.6 Conditional filtering 17.7 Filtering data frames 17.8 dplyr::filter", " 17 Selection and filtering 17.1 dplyr The dplyr (pronounced dee-ply-er) library is part of tidyverse and it offers a grammar for data manipulation select: select specific columns filter: select specific rows arrange: arrange rows in a particular order summarise: calculate aggregated values (e.g., mean, max, etc) group_by: group data based on common column values mutate: add columns join: merge data frames library(tidyverse) 17.2 Example dataset The library nycflights13 contains a dataset storing data about all the flights departed from New York City in 2013 install.packages(&quot;nycflights13&quot;) library(nycflights13) flights_from_nyc &lt;- nycflights13::flights colnames(flights_from_nyc) ## [1] &quot;year&quot; &quot;month&quot; &quot;day&quot; &quot;dep_time&quot; ## [5] &quot;sched_dep_time&quot; &quot;dep_delay&quot; &quot;arr_time&quot; &quot;sched_arr_time&quot; ## [9] &quot;arr_delay&quot; &quot;carrier&quot; &quot;flight&quot; &quot;tailnum&quot; ## [13] &quot;origin&quot; &quot;dest&quot; &quot;air_time&quot; &quot;distance&quot; ## [17] &quot;hour&quot; &quot;minute&quot; &quot;time_hour&quot; 17.3 dplyr::select select can be used to specify which columns to retain delays &lt;- select(flights_from_nyc, origin, dest, dep_delay, arr_delay, year:day ) # Drop column arr_delay using - in front of the column name dep_delays &lt;- select(delays, -arr_delay) delays[1:3, ] ## # A tibble: 3 x 7 ## origin dest dep_delay arr_delay year month day ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 EWR IAH 2 11 2013 1 1 ## 2 LGA IAH 4 20 2013 1 1 ## 3 JFK MIA 2 33 2013 1 1 17.4 dplyr::select … using the pipe operator dep_delays &lt;- flights_from_nyc %&gt;% select(origin, dest, dep_delay, arr_delay, year:day) %&gt;% select(-arr_delay) delays[1:3, ] ## # A tibble: 3 x 7 ## origin dest dep_delay arr_delay year month day ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 EWR IAH 2 11 2013 1 1 ## 2 LGA IAH 4 20 2013 1 1 ## 3 JFK MIA 2 33 2013 1 1 17.5 Logical filtering Conditional statements can be used to filter a vector, i.e. to retain only certain values a_numeric_vector &lt;- -3:3 a_numeric_vector ## [1] -3 -2 -1 0 1 2 3 a_numeric_vector[c(FALSE, FALSE, FALSE, TRUE, TRUE, TRUE, TRUE)] ## [1] 0 1 2 3 17.6 Conditional filtering As a condition expression results in a logic vector, that condition can be used for filtering a_numeric_vector &gt; 0 ## [1] FALSE FALSE FALSE FALSE TRUE TRUE TRUE a_numeric_vector[a_numeric_vector &gt; 0] ## [1] 1 2 3 17.7 Filtering data frames The same can be applied to data frames nov_dep_delays &lt;- dep_delays[dep_delays$month == 11, ] nov_dep_delays[1:3, ] ## # A tibble: 3 x 6 ## origin dest dep_delay year month day ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 JFK PSE 6 2013 11 1 ## 2 JFK SYR 105 2013 11 1 ## 3 EWR CLT -5 2013 11 1 17.8 dplyr::filter nov_dep_delays &lt;- dep_delays %&gt;% filter(month == 11) # Flights in November nov_dep_delays[1:3, ] ## # A tibble: 3 x 6 ## origin dest dep_delay year month day ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 JFK PSE 6 2013 11 1 ## 2 JFK SYR 105 2013 11 1 ## 3 EWR CLT -5 2013 11 1 "],
["manipulate.html", "18 Manipulate 18.1 dplyr::arrange 18.2 dplyr::summarise 18.3 dplyr::group_by 18.4 dplyr::mutate 18.5 Full pipe example", " 18 Manipulate 18.1 dplyr::arrange nov_dep_delays &lt;- nov_dep_delays %&gt;% arrange( dest, # Ascending destination name -dep_delay # Descending delay ) nov_dep_delays[1:3, ] ## # A tibble: 3 x 6 ## origin dest dep_delay year month day ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 JFK ABQ 25 2013 11 29 ## 2 JFK ABQ 21 2013 11 22 ## 3 JFK ABQ 17 2013 11 21 18.2 dplyr::summarise summarise: calculate aggregated values (e.g., mean, max, etc) aggr_dep_delays_nov &lt;- nov_dep_delays %&gt;% # Need to filter out rows where delay is NA filter(!is.na(dep_delay)) %&gt;% # Create two aggregated columns summarize( avg_dep_delay = mean(dep_delay), tot_dep_delay = sum(dep_delay) ) aggr_dep_delays_nov ## # A tibble: 1 x 2 ## avg_dep_delay tot_dep_delay ## &lt;dbl&gt; &lt;dbl&gt; ## 1 5.44 146945 18.3 dplyr::group_by dest_dep_delays_nov &lt;- nov_dep_delays %&gt;% # Need to filter out rows where delay is NA filter(!is.na(dep_delay)) %&gt;% # Frist group by same destination group_by(dest) %&gt;% # Then caluculate aggregated value summarize( tot_dep_delay = sum(dep_delay) ) dest_dep_delays_nov[1:3, ] ## # A tibble: 3 x 2 ## dest tot_dep_delay ## &lt;chr&gt; &lt;dbl&gt; ## 1 ABQ -66 ## 2 ALB 636 ## 3 ATL 8184 18.4 dplyr::mutate dest_dep_delays_nov &lt;- dest_dep_delays_nov %&gt;% mutate( tot_dep_delay_days = ((tot_dep_delay / 60) /24) ) dest_dep_delays_nov[1:3, ] ## # A tibble: 3 x 3 ## dest tot_dep_delay tot_dep_delay_days ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 ABQ -66 -0.0458 ## 2 ALB 636 0.442 ## 3 ATL 8184 5.68 18.5 Full pipe example dest_dep_delays_nov &lt;- nycflights13::flights %&gt;% select(origin, dest, dep_delay, arr_delay, year:day) %&gt;% select(-arr_delay) %&gt;% filter(month == 11) %&gt;% filter(!is.na(dep_delay)) %&gt;% arrange(dest, -dep_delay) %&gt;% group_by(dest) %&gt;% summarize(tot_dep_delay = sum(dep_delay)) %&gt;% mutate(tot_dep_delay_days = ((tot_dep_delay / 60) /24)) dest_dep_delays_nov[1:3, ] ## # A tibble: 3 x 3 ## dest tot_dep_delay tot_dep_delay_days ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 ABQ -66 -0.0458 ## 2 ALB 636 0.442 ## 3 ATL 8184 5.68 "],
["summary-6.html", "19 Summary 19.1 Summary 19.2 Practical session 19.3 Next week", " 19 Summary 19.1 Summary Moving on towards data science Data selection Data filtering Data manipulation 19.2 Practical session In the practical session we will see Creating R projects Creating R scripts Data selection Data filtering Data manipulation 19.3 Next week Moving on towards data science Join operations Table re-shaping Read and write data "],
["recap-202.html", "20 Recap @ 202 20.1 Previous lectures 20.2 Today", " 20 Recap @ 202 20.1 Previous lectures Moving on towards data science Data selection Data filtering Data manipulation 20.2 Today Moving on towards data science Join operations Table re-shaping Read and write data "],
["join.html", "21 Join 21.1 Joining data 21.2 Join types 21.3 Example 21.4 Example 21.5 dplyr::full_join 21.6 dplyr::left_join 21.7 dplyr::right_join 21.8 dplyr::inner_join", " 21 Join 21.1 Joining data Data frames can be joined (or ‘merged’) information from two data frames can be combined specifying a column with common values usually one with a unique identifier of an entity rows having the same value are joined depending on parameters a row from one data frame can be merged with multiple rows from the other data frame rows with no matching values in the other data frame can be retained merge base function or join functions in dplyr 21.2 Join types by C.L. Moffatt, licensed under The Code Project Open License (CPOL) 21.3 Example employees &lt;- data.frame( Name = c(&quot;Maria&quot;, &quot;Pete&quot;, &quot;Sarah&quot;, &quot;Jo&quot;), Age = c(47, 34, 32, 25), Role = c(&quot;Professor&quot;, &quot;Researcher&quot;, &quot;Researcher&quot;, &quot;Postgrad&quot;) ) city_of_birth &lt;-data.frame( Name = c(&quot;Maria&quot;, &quot;Pete&quot;, &quot;Sarah&quot;, &quot;Mel&quot;), City = c(&quot;Barcelona&quot;, &quot;London&quot;, &quot;Boston&quot;, &quot;Los Angeles&quot;) ) 21.4 Example Name Age Role Maria 47 Professor Pete 34 Researcher Sarah 32 Researcher Jo 25 Postgrad Name City Maria Barcelona Pete London Sarah Boston Mel Los Angeles 21.5 dplyr::full_join dplyr provides a series of join functions full_join combines all the available data employees %&gt;% full_join( city_of_birth, by = c(&quot;Name&quot; = &quot;Name&quot;) # join columns ) %&gt;% kable() Name Age Role City Maria 47 Professor Barcelona Pete 34 Researcher London Sarah 32 Researcher Boston Jo 25 Postgrad NA Mel NA NA Los Angeles 21.6 dplyr::left_join left_join keeps all the data from the left table using %&gt;%, that’s the data “coming down the pipe” rows from the right table without a match are dropped employees %&gt;% left_join( city_of_birth, by = c(&quot;Name&quot; = &quot;Name&quot;) # join columns ) %&gt;% kable() Name Age Role City Maria 47 Professor Barcelona Pete 34 Researcher London Sarah 32 Researcher Boston Jo 25 Postgrad NA 21.7 dplyr::right_join right_join keeps all the data from the right table using %&gt;%, that’s the data provided as an argument rows from the left table without a match are dropped employees %&gt;% right_join( city_of_birth, by = c(&quot;Name&quot; = &quot;Name&quot;) # join columns ) %&gt;% kable() Name Age Role City Maria 47 Professor Barcelona Pete 34 Researcher London Sarah 32 Researcher Boston Mel NA NA Los Angeles 21.8 dplyr::inner_join inner_join keeps only rows that have a match in both tables rows without a match are dropped employees %&gt;% inner_join( city_of_birth, by = c(&quot;Name&quot; = &quot;Name&quot;) # join columns ) %&gt;% kable() Name Age Role City Maria 47 Professor Barcelona Pete 34 Researcher London Sarah 32 Researcher Boston "],
["re-shape.html", "22 Re-shape 22.1 Wide data 22.2 Long data 22.3 tidyr 22.4 tidyr::gather 22.5 tidyr::spread", " 22 Re-shape 22.1 Wide data This is the most common approach each real-world entity is represented by one single row its attributes are represented through different columns City Population Area Density Leicester 329,839 73.3 4,500 Nottingham 321,500 74.6 4,412 22.2 Long data This is probably a less common approach, but still necessary in many cases each real-world entity is represented by multiple rows each one reporting only one of its attributes one column indicates which attribute each row represent another column is used to report the value City Attribute Value Leicester Population 329,839 Leicester Area 73.3 Leicester Density 4,500 Nottingham Population 321,500 Nottingham Area 74.6 Nottingham Density 4,412 22.3 tidyr The tidyr (pronounced tidy-er) library is part of tidyverse and it provides functions to re-shape your data city_info_wide &lt;- data.frame( City = c(&quot;Leicester&quot;, &quot;Nottingham&quot;), Population = c(329839, 321500), Area = c(73.3, 74.6), Density = c(4500, 4412) ) kable(city_info_wide) City Population Area Density Leicester 329839 73.3 4500 Nottingham 321500 74.6 4412 22.4 tidyr::gather Re-shape from wide to long format city_info_long &lt;- city_info_wide %&gt;% gather( -City, # exclude city names from gathering key = &quot;Attribute&quot;, # name for the new key column value = &quot;Value&quot; # name for the new value column ) City Attribute Value Leicester Population 329839.0 Nottingham Population 321500.0 Leicester Area 73.3 Nottingham Area 74.6 Leicester Density 4500.0 Nottingham Density 4412.0 22.5 tidyr::spread Rre-shape from long to wide format city_info_back_to_wide &lt;- city_info_long %&gt;% spread( key = &quot;Attribute&quot;, # specify key column value = &quot;Value&quot; # specify value column ) City Area Density Population Leicester 73.3 4500 329839 Nottingham 74.6 4412 321500 "],
["read-and-write.html", "23 Read and write 23.1 Comma Separated Values 23.2 Read 23.3 Write", " 23 Read and write 23.1 Comma Separated Values The file 2011_OAC_Raw_uVariables_Leicester.csv - contains data used for the 2011 Output Area Classificagtion - 167 variables, as well as the resulting groups - for the city of Leicester Extract showing only some columns OA11CD,LSOA11CD, ... supgrpcode,supgrpname,Total_Population, ... E00069517,E01013785, ... 6,Suburbanites,313, ... E00169516,E01013713, ... 4,Multicultural Metropolitans,341, ... E00169048,E01032862, ... 4,Multicultural Metropolitans,345, ... The full variable names can be found in the file - 2011_OAC_Raw_uVariables_Lookup.csv. 23.2 Read The read_csv function of the readr library reads a csv file from the path provided as the first argument leicester_2011OAC &lt;- read_csv(&quot;2011_OAC_Raw_uVariables_Leicester.csv&quot;) leicester_2011OAC %&gt;% select(OA11CD,LSOA11CD, supgrpcode,supgrpname,Total_Population) %&gt;% top_n(3) %&gt;% kable() OA11CD LSOA11CD supgrpcode supgrpname Total_Population E00169553 E01013648 2 Cosmopolitans 714 E00069303 E01013739 4 Multicultural Metropolitans 623 E00168096 E01013689 2 Cosmopolitans 708 23.3 Write The function write_csv can be used to save a dataset to csv Example: read the 2011 OAC dataset select a few columns filter only those OA in the supergroup Suburbanites (code 6) write the results to a file named Leicester_Suburbanites.csv in your home folder read_csv(&quot;2011_OAC_Raw_uVariables_Leicester.csv&quot;) %&gt;% select(OA11CD, supgrpcode, supgrpname) %&gt;% filter(supgrpcode == 6) %&gt;% write_csv(&quot;~/Leicester_Suburbanites.csv&quot;) "],
["summary-8.html", "24 Summary 24.1 Summary 24.2 Practical session 24.3 Next week", " 24 Summary 24.1 Summary Moving on towards data science Join operations Table re-shaping Read and write data 24.2 Practical session In the practical session, we will see Re-shaping: long and wide formats Join operations Read and write data 24.3 Next week Reproducibility in (geographic) data science What is reproducible data analysis? why is it important? software engineering practical principles Tools Markdown knitr and rmarkdown Git "],
["recap-301.html", "25 Recap @ 301 25.1 Previous lectures 25.2 Today", " 25 Recap @ 301 25.1 Previous lectures Moving from programming to data science Basic types and variables The pipe operator Complex data types Data wrangling Data selection Data filtering Data manipulation Join operations Table re-shaping Read and write data 25.2 Today Reproducibility in (geographic) data science What is reproducible data analysis? why is it important? software engineering practical principles Tools Markdown RMarkdown Git See also: Christopher Gandrud, Reproducible Research with R and R Studio also available on GitHub "],
["reproducibility.html", "26 Reproducibility 26.1 Reproduciblity 26.2 Why? 26.3 Reproducibility and software engineering 26.4 Reproducibility and “big data” 26.5 Reproducibility in GIScience 26.6 Document everything 26.7 Future-proof formats 26.8 Human-readable 26.9 Workflow 26.10 Store and share 26.11 This repository", " 26 Reproducibility 26.1 Reproduciblity In quantitative research, an analysis or project are considered to be reproducible if: “the data and code used to make a finding are available and they are sufficient for an independent researcher to recreate the finding.” Christopher Gandrud, Reproducible Research with R and R Studio That is becoming more and more important in science: as programming and scripting are becoming integral in most disciplines as the amount of data increases 26.2 Why? In scientific research: verificability of claims through replication incremental work, avoid duplication For your working practice: better working practices coding project structure versioning better teamwork higher impact (not just results, but code, data, etc.) 26.3 Reproducibility and software engineering Core aspects of software engineering are: project design software readibility testing versioning As programming becomes integral to research, similar necessities arise among scientists and data analysts. 26.4 Reproducibility and “big data” There has been a lot of discussions about “big data”… volume, velocity, variety, … Beyond the hype of the moment, as the amount and complexity of data increases the time required to replicate an analysis using point-and-click software becomes unsustainable room for error increases Workflow management software (e.g., ArcGIS ModelBuilder) is one answer, reproducible data analysis based on script languages like R is another. 26.5 Reproducibility in GIScience Singleton et al. have discussed the issue of reproducibility in GIScience, identifying the following best practices: Data should be accessible within the public domain and available to researchers. Software used should have open code and be scrutable. Workflows should be public and link data, software, methods of analysis and presentation with discursive narrative The peer review process and academic publishing should require submission of a workflow model and ideally open archiving of those materials necessary for replication. Where full reproducibility is not possible (commercial software or sensitive data) aim to adopt aspects attainable within circumstances 26.6 Document everything In order to be reproducible, every step of your project should be documented in detail data gathering data analysis results presentation Well documented R scripts are and excellent way to document your project. 26.7 Future-proof formats Complex formats (e.g., .docx, .xlsx, .shp, ArcGIS .mxd) can become obsolete are not always portable usually require proprietary software Use the simplest format to future-proof your analysis.Text files are the most versatile data: .txt, .csv, .tsv analysis: R scrpts, python scripts write-up: LaTeX, Markdown, HTML 26.8 Human-readable Create code that can be easily understandable to someone outside your project, including yourself in six-month time! use a style guide (e.g. tidyverse) consistently add a comment at the beginning of a file, including date contributors other files the current file depends on materials, sources and other references add a comment before each code block, describing what the code does also add a comment before any line that could be ambiguous or particularly difficult or important 26.9 Workflow Relationships between files in a project are not simple: in which order are file executed? when to copy files from one folder to another, and where? A common solution is using make files commonly written in bash on Linux systems they can be written in R, using commands like source to execute R scripts system to interact with the operative system 26.10 Store and share Reproducible data analysis is particularly important when working in teams, to share and communicate your work. Dropbox good option to work in teams, initially free no versioning, branches Git free and opensource control system great to work in teams and share your work publically can be more difficult at first GitHub public repositories are free, private ones are not GitLab offers free private repositories 26.11 This repository My GitHub repository GY7702 stores lectures and practical session materials for this module https://github.com/sdesabbata/GY7702 GitHub Page at https://sdesabbata.github.io/GY7702/ "],
["rmarkdown.html", "27 RMarkdown 27.1 Markdown 27.2 Markdown example code 27.3 Markdown example output 27.4 RMarkdown example code 27.5 Writing RMarkdown docs", " 27 RMarkdown 27.1 Markdown Markdown is a simple markup language allows to mark-up plain text to specify more complex features (such as italics text) using a very simple syntax Markdown can be used in conjunction with numerous tools to produce HTML pages or even more complex formats (such as PDF) These slides are written in Markdown 27.2 Markdown example code ### This is a third level heading Text can be specified as *italic* or **bold** - and list can be created - very simply 1. also numbered lists 1. [add a link like this](http://le.ac.uk) |Tables |Can |Be | |-------|------------|---------| |a bit |complicated |at first | |but |it gets |easier | 27.3 Markdown example output 27.3.1 This is a third level heading Text can be specified as italic or bold and list can be created very simply also numbered lists add a link like this Tables Can Be a bit complicated at first but it gets easier 27.4 RMarkdown example code Let&#39;s write an example of **R** code including - a variable `a_variable` - an assignment operation (i.e., `&lt;-`) - a mathematical operation (i.e., `+`) ```{r, echo=TRUE} a_variable &lt;- 0 a_variable &lt;- a_variable + 1 a_variable &lt;- a_variable + 1 a_variable &lt;- a_variable + 1 a_variable ``` 27.5 Writing RMarkdown docs RMarkdown documents contain both Markdown and R code. These files can be created in RStudio, and compiled to create an html page (like this document), a pdf, or a Microsoft Word document. "],
["git.html", "28 Git 28.1 What’s git? 28.2 How git works 28.3 Three stages 28.4 Basic git commands 28.5 Git and RStudio", " 28 Git 28.1 What’s git? Git is a free and opensource version control system commonly used through a server where a master copy of a project is kept can also be used locally allows storing versions of a project syncronisation consistency history multiple branches 28.2 How git works A series of snapshots each commit is a snapshot of all files if no change to a file, link to previous commit all history stored locally by Scott Chacon and Ben Straub, licensed under CC BY-NC-SA 3.0 28.3 Three stages When working with a git repository first checkout the latest version select the edits to stage commit what has been staged in a permanent snapshot by Scott Chacon and Ben Straub, licensed under CC BY-NC-SA 3.0 28.4 Basic git commands git clone copy a repository from a server git fetch get the latest version from a branch git pull incorporate changes from a remote repository git add stage new files git commit create a commit git push upload commits to a remote repository 28.5 Git and RStudio RStudio includes a git plug-in clone R projects from repositories stage and commit changes push and pull changes "],
["summary-10.html", "29 Summary 29.1 Summary 29.2 Practical session 29.3 Next week", " 29 Summary 29.1 Summary Reproducibility in (geographic) data science What is reproducible data analysis? why is it important? software engineering practical principles Tools Markdown RMarkdown Git 29.2 Practical session In the practical session, we will see Markdown Git Examples of reproducible data analysis 29.3 Next week Exploratory data analysis "],
["recap-501.html", "30 Recap @ 501 30.1 Previous lectures 30.2 Today", " 30 Recap @ 501 30.1 Previous lectures What is reproducible data analysis? why is it important? software engineering practical principles Tools Markdown RMarkdown Git 30.2 Today Data visualisation histograms boxplots scatterplots Descriptive statistics Exploring assumptions Shapiro–Wilk test skewness and kurtosis Levene’s test "],
["data-visualisation.html", "31 Data visualisation 31.1 Visual variables 31.2 Grammar of graphics 31.3 ggplot2 31.4 Histograms 31.5 Histograms 31.6 Boxplots 31.7 Boxplots 31.8 Jittered points 31.9 Jittered points 31.10 Jittered points 31.11 Jittered points 31.12 Lines 31.13 Lines 31.14 Scatterplots 31.15 Scatterplots 31.16 Overlapping points 31.17 Overlapping points 31.18 Bin counts 31.19 Bin counts", " 31 Data visualisation 31.1 Visual variables A visual variable is an aspect of a mark that can be controlled to change its appearance. Visual variables include: Size Shape Orientation Colour (hue) Colour value (brightness) Texture Position (2 dimensions) 31.2 Grammar of graphics Grammars provide rules for languages “The grammar of graphics takes us beyond a limited set of charts (words) to an almost unlimited world of graphical forms (statements)” (Wilkinson, 2005) Statistical graphic specifications are expressed in six statements: Data manipulation Variable transformations (e.g., rank), Scale transformations (e.g., log), Coordinate system transformations (e.g., polar), Element: mark (e.g., points) and visual variables (e.g., color) Guides (axes, legends, etc.). 31.3 ggplot2 The ggplot2 library offers a series of functions for creating graphics declaratively, based on the Grammar of Graphics. To create a graph in ggplot2: provide the data specify elements which visual variables (aes) which marks (e.g., geom_point) apply transformations guides library(tidyverse) library(nycflights13) library(knitr) 31.4 Histograms x variable to plot geom_histogram nycflights13::flights %&gt;% filter(month == 11) %&gt;% ggplot( aes( x = dep_delay ) ) + geom_histogram( binwidth = 10 ) 31.5 Histograms 31.6 Boxplots x categorical variable y variable to plot geom_boxplot nycflights13::flights %&gt;% filter(month == 11) %&gt;% ggplot( aes( x = carrier, y = arr_delay ) ) + geom_boxplot() 31.7 Boxplots 31.8 Jittered points x categorical variable y variable to plot geom_jitter nycflights13::flights %&gt;% filter(month == 11) %&gt;% ggplot( aes( x = carrier, y = arr_delay ) ) + geom_jitter() 31.9 Jittered points 31.10 Jittered points x categorical variable y variable to plot geom_jitter nycflights13::flights %&gt;% filter(month == 11) %&gt;% ggplot( aes( x = carrier, y = arr_delay ) ) + geom_violin() 31.11 Jittered points 31.12 Lines x e.g., a temporal variable y variable to plot geom_line nycflights13::flights %&gt;% filter(!is.na(dep_delay)) %&gt;% mutate(flight_date = ISOdate(year, month, day)) %&gt;% group_by(flight_date) %&gt;% summarize(avg_dep_delay = mean(dep_delay)) %&gt;% ggplot(aes( x = flight_date, y = avg_dep_delay )) + geom_line() 31.13 Lines 31.14 Scatterplots x and y variable to plot geom_point nycflights13::flights %&gt;% filter( month == 11, carrier == &quot;US&quot;, !is.na(dep_delay), !is.na(arr_delay) ) %&gt;% ggplot(aes( x = dep_delay, y = arr_delay )) + geom_point() 31.15 Scatterplots 31.16 Overlapping points x and y variable to plot geom_count counts overlapping points and maps the count to size nycflights13::flights %&gt;% filter( month == 11, carrier == &quot;US&quot;, !is.na(dep_delay), !is.na(arr_delay) ) %&gt;% ggplot(aes( x = dep_delay, y = arr_delay )) + geom_count() 31.17 Overlapping points 31.18 Bin counts x and y variable to plot geom_bin2d nycflights13::flights %&gt;% filter( month == 11, carrier == &quot;US&quot;, !is.na(dep_delay), !is.na(arr_delay) ) %&gt;% ggplot(aes( x = dep_delay, y = arr_delay )) + geom_bin2d() 31.19 Bin counts "],
["descriptive-statistics.html", "32 Descriptive statistics 32.1 Descriptive statistics 32.2 stat.desc output 32.3 stat.desc: basic 32.4 stat.desc: desc 32.5 Sample statistics 32.6 Estimating variation", " 32 Descriptive statistics 32.1 Descriptive statistics Quantitatively describe or summarize variables stat.desc from pastecs library base includes counts desc includes descriptive stats norm (default is FALSE) includes distribution stats library(pastecs) nycflights13::flights %&gt;% filter(month == 11, carrier == &quot;US&quot;) %&gt;% select(dep_delay, arr_delay, distance) %&gt;% stat.desc() %&gt;% kable() 32.2 stat.desc output dep_delay arr_delay distance nbr.val 1668.0000000 1667.000000 1.699000e+03 nbr.null 58.0000000 35.000000 0.000000e+00 nbr.na 31.0000000 32.000000 0.000000e+00 min -17.0000000 -63.000000 9.600000e+01 max 193.0000000 191.000000 2.153000e+03 range 210.0000000 254.000000 2.057000e+03 sum 961.0000000 -4450.000000 9.715580e+05 median -4.0000000 -7.000000 5.290000e+02 mean 0.5761391 -2.669466 5.718411e+02 SE.mean 0.4084206 0.518816 1.464965e+01 CI.mean.0.95 0.8010713 1.017600 2.873327e+01 var 278.2347513 448.706408 3.646264e+05 std.dev 16.6803702 21.182691 6.038430e+02 coef.var 28.9519850 -7.935179 1.055963e+00 32.3 stat.desc: basic nbr.val: overall number of values in the dataset nbr.null: number of NULL values – NULL is often returned by expressions and functions whose values are undefined nbr.na: number of NAs – missing value indicator 32.4 stat.desc: desc min (also min()): minimum value in the dataset max (also max()): minimum value in the dataset range: difference between min and max (different from range()) sum (also sum()): sum of the values in the dataset mean (also mean()): arithmetic mean, that is sum over the number of values not NA median (also median()): median, that is the value separating the higher half from the lower half the values mode()functio is available: mode, the value that appears most often in the values 32.5 Sample statistics Assuming that the data in the dataset are a sample of a population SE.mean: standard error of the mean – estimation of the variability of the mean calculated on different samples of the data (see also central limit theorem) CI.mean.0.95: 95% confidence interval of the mean – indicates that there is a 95% probability that the actual mean is within that distance from the sample mean 32.6 Estimating variation var: variance (\\(\\sigma^2\\)), it quantifies the amount of variation as the average of squared distances from the mean \\[\\sigma^2 = \\frac{1}{n} \\sum_{i=1}^n (\\mu-x_i)^2\\] std.dev: standard deviation (\\(\\sigma\\)), it quantifies the amount of variation as the square root of the variance \\[\\sigma = \\sqrt{\\frac{1}{n} \\sum_{i=1}^n (\\mu-x_i)^2}\\] coef.var: variation coefficient it quantifies the amount of variation as the standard deviation divided by the mean "],
["exploring-assumptions.html", "33 Exploring assumptions 33.1 Normal distribution 33.2 Density histogram 33.3 Q-Q plot 33.4 stat.desc: norm 33.5 Normality 33.6 Significance 33.7 Skewness and kurtosis 33.8 Homogeneity of variance", " 33 Exploring assumptions 33.1 Normal distribution characterized by the bell-shaped curve majority of values lie around the centre of the distribution the further the values are from the centre, the lower their frequency about 95% of values within 2 standard deviations from the mean 33.2 Density histogram nycflights13::flights %&gt;% ggplot( aes( x = dep_delay ) ) + geom_histogram( aes( y =..density.. ), binwidth = 10 ) + stat_function( fun = dnorm, args = list( mean = dep_delay_mean, sd = dep_delay_sd), colour = &quot;black&quot;, size = 1) 33.3 Q-Q plot Cumulative values against the cumulative probability of a particular distribution nycflights13::flights %&gt;% filter( month == 11, carrier == &quot;US&quot; ) %&gt;% qplot( sample = dep_delay, data = ., stat = &quot;qq&quot;, xlab = &quot;Theoretical&quot;, ylab = &quot;Sample&quot; ) 33.4 stat.desc: norm nycflights13::flights %&gt;% filter(month == 11, carrier == &quot;US&quot;) %&gt;% select(dep_delay, arr_delay, distance) %&gt;% stat.desc(basic = FALSE, desc = FALSE, norm = TRUE) %&gt;% kable() dep_delay arr_delay distance skewness 4.4187763 2.0716291 2.0030249 skew.2SE 36.8709612 17.2808242 16.8678747 kurtosis 28.8513206 9.5741004 2.6000743 kurt.2SE 120.4418092 39.9557893 10.9542887 normtest.W 0.5545326 0.8657894 0.6012442 normtest.p 0.0000000 0.0000000 0.0000000 33.5 Normality Shapiro–Wilk test compares the distribution of a variable with a normal distribution having same mean and standard deviation If significant, the distribution is not normal normtest.W (test statistics) and normtest.p (significance) also, shapiro.test function is available nycflights13::flights %&gt;% filter(month == 11, carrier == &quot;US&quot;) %&gt;% pull(dep_delay) %&gt;% shapiro.test() ## ## Shapiro-Wilk normality test ## ## data: . ## W = 0.55453, p-value &lt; 2.2e-16 33.6 Significance Most statistical tests are based on the idea of hypothesis testing a null hypothesis is set the data are fit into a statistical model the model is assessed with a test statistic the significance is the probability of obtaining that test statistic value by chance The threshold to accept or reject an hypotheis is arbitrary and based on conventions (e.g., p &lt; .01 or p &lt; .05) Example: The null hypotheis of the Shapiro–Wilk test is that the sample is normally distributed and p &lt; .01 indicates that the probability of that being true is very low. 33.7 Skewness and kurtosis In a normal distribution, the values of skewness and kurtosis should be zero skewness: skewness value indicates positive: the distribution is skewed towards the left negative: the distribution is skewed towards the right kurtosis: kurtosis value indicates positive: heavy-tailed distribution negative: flat distribution skew.2SE and kurt.2SE: skewness and kurtosis divided by 2 standard errors. If greater than 1, the respective statistics is significant (p &lt; .05). 33.8 Homogeneity of variance Levene’s test for equality of variance in different levels If significant, the variance is different in different levels dep_delay_carrier &lt;- nycflights13::flights %&gt;% filter(month == 11) %&gt;% select(dep_delay, carrier) library(car) leveneTest(dep_delay_carrier$dep_delay, dep_delay_carrier$carrier) ## Levene&#39;s Test for Homogeneity of Variance (center = median) ## Df F value Pr(&gt;F) ## group 15 20.203 &lt; 2.2e-16 *** ## 27019 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 "],
["summary-12.html", "34 Summary 34.1 Summary 34.2 Practical session", " 34 Summary 34.1 Summary Data visualisation histograms boxplots scatterplots Descriptive statistics Exploring assumptions Shapiro–Wilk test skewness and kurtosis Levene’s test 34.2 Practical session In the practical session, we will see: Data visualisation histograms boxplots scatterplots Descriptive statistics Exploring assumptions Shapiro–Wilk test skewness and kurtosis Levene’s test "],
["recap-502.html", "35 Recap @ 502 35.1 Previous lectures 35.2 Today", " 35 Recap @ 502 35.1 Previous lectures TODO 35.2 Today TODO "],
["correlation.html", "36 Correlation 36.1 Correlation 36.2 Pearson’s r 36.3 Spearman’s coefficient 36.4 Kendall’s tau 36.5 Pairs plot", " 36 Correlation 36.1 Correlation 36.2 Pearson’s r 36.3 Spearman’s coefficient 36.4 Kendall’s tau 36.5 Pairs plot "],
["data-transformations.html", "37 Data transformations", " 37 Data transformations "],
["z-scores.html", "38 Z-scores 38.1 Log transformation 38.2 Inverse hyperbolic sine", " 38 Z-scores 38.1 Log transformation 38.2 Inverse hyperbolic sine "],
["regression.html", "39 Regression 39.1 Least squares 39.2 Example 39.3 Overall fit 39.4 Parameters 39.5 Outliers and residuals 39.6 Influential cases 39.7 Checking assumptions 39.8 Normally distributed errors 39.9 Homoscedasticity 39.10 Independent errors", " 39 Regression 39.1 Least squares 39.2 Example library(tidyverse) ## ── Attaching packages ──────────────────────────────────────────────────────────────────────────────── tidyverse 1.2.1 ── ## ✔ ggplot2 3.2.1 ✔ purrr 0.3.2 ## ✔ tibble 2.1.3 ✔ dplyr 0.8.3 ## ✔ tidyr 1.0.0 ✔ stringr 1.4.0 ## ✔ readr 1.3.1 ✔ forcats 0.4.0 ## ── Conflicts ─────────────────────────────────────────────────────────────────────────────────── tidyverse_conflicts() ── ## ✖ dplyr::filter() masks stats::filter() ## ✖ dplyr::lag() masks stats::lag() library(nycflights13) nycflights13::flights %&gt;% filter(month == 11, carrier == &quot;US&quot;) %&gt;% lm(dep_delay ~ arr_delay, data = .) %&gt;% summary() ## ## Call: ## lm(formula = dep_delay ~ arr_delay, data = .) ## ## Residuals: ## Min 1Q Median 3Q Max ## -39.980 -5.771 -0.242 5.031 77.074 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 2.24171 0.25232 8.885 &lt;2e-16 *** ## arr_delay 0.62268 0.01182 52.674 &lt;2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 10.22 on 1665 degrees of freedom ## (32 observations deleted due to missingness) ## Multiple R-squared: 0.625, Adjusted R-squared: 0.6247 ## F-statistic: 2775 on 1 and 1665 DF, p-value: &lt; 2.2e-16 #filter(!is.na(dep_delay)) %&gt;% 39.3 Overall fit 39.4 Parameters Beta 39.5 Outliers and residuals 39.6 Influential cases 39.7 Checking assumptions 39.8 Normally distributed errors 39.9 Homoscedasticity 39.10 Independent errors "],
["comparing-means.html", "40 Comparing means 40.1 Independent t-test 40.2 Reporting results 40.3 Dependent t-test 40.4 Reporting results", " 40 Comparing means 40.1 Independent t-test 40.2 Reporting results 40.3 Dependent t-test 40.4 Reporting results "],
["summary-14.html", "41 Summary 41.1 Summary 41.2 Practical session", " 41 Summary 41.1 Summary TODO 41.2 Practical session In the practical session we will see: TODO "],
["recap-601.html", "42 Recap @ 601 42.1 Previous lectures 42.2 Today", " 42 Recap @ 601 42.1 Previous lectures TODO 42.2 Today TODO "],
["machine-learning.html", "43 Machine Learning 43.1 Definition 43.2 Origines 43.3 Types of machine learning 43.4 Unsupervised 43.5 Supervised 43.6 Neural networks 43.7 Deep neural networks 43.8 Convolutional neural networks 43.9 Limits", " 43 Machine Learning 43.1 Definition 43.2 Origines 43.3 Types of machine learning Unsupervised (descriptive) Supervised (predictive) 43.4 Unsupervised 43.5 Supervised 43.6 Neural networks 43.7 Deep neural networks 43.8 Convolutional neural networks 43.9 Limits Incl. overfitting "],
["clustering.html", "44 Clustering 44.1 Clustering task 44.2 k-means 44.3 fuzzy c-means 44.4 Hierarchical clustering 44.5 Bagged clustering 44.6 Density based clustering 44.7 Geodemographic classifications", " 44 Clustering 44.1 Clustering task 44.2 k-means 44.3 fuzzy c-means 44.4 Hierarchical clustering 44.5 Bagged clustering 44.6 Density based clustering 44.7 Geodemographic classifications "],
["summary-16.html", "45 Summary 45.1 Summary 45.2 Practical session", " 45 Summary 45.1 Summary TODO 45.2 Practical session In the practical session we will see: TODO "],
["recap-611.html", "46 Recap @ 611 46.1 Previous lectures 46.2 Today", " 46 Recap @ 611 46.1 Previous lectures TODO 46.2 Today TODO "],
["k-nearest-neighbors.html", "47 k Nearest Neighbors 47.1 Classification task 47.2 k Nearest Neighbors 47.3 Choosing k", " 47 k Nearest Neighbors 47.1 Classification task 47.2 k Nearest Neighbors 47.3 Choosing k "],
["neural-networks-1.html", "48 Neural networks 48.1 Artificial Neural Networks 48.2 Artificial neurons 48.3 Activation functions 48.4 Network topology 48.5 Deep Neural Networks 48.6 Recurrent Neural Networks 48.7 Backpropagation 48.8 Training 48.9 Evaluation", " 48 Neural networks 48.1 Artificial Neural Networks 48.2 Artificial neurons 48.3 Activation functions 48.4 Network topology 48.5 Deep Neural Networks 48.6 Recurrent Neural Networks 48.7 Backpropagation 48.8 Training 48.9 Evaluation "],
["support-vector-machines.html", "49 Support Vector Machines 49.1 Support Vector Machines 49.2 Maximum Margin Hyperplane 49.3 Support Vectors 49.4 Linearly separable 49.5 Non-linearly separable 49.6 Kernels", " 49 Support Vector Machines 49.1 Support Vector Machines 49.2 Maximum Margin Hyperplane 49.3 Support Vectors 49.4 Linearly separable 49.5 Non-linearly separable 49.6 Kernels "],
["summary-18.html", "50 Summary 50.1 Summary 50.2 Practical session", " 50 Summary 50.1 Summary TODO 50.2 Practical session In the practical session we will see: TODO "]
]
